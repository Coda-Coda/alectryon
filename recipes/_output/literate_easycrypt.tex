\documentclass[a4paper]{article}
% generated by Docutils <http://docutils.sourceforge.net/>
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{alltt}
\usepackage{color}
\usepackage{textcomp} % text symbol macros

%%% Custom LaTeX preamble

\usepackage[margin=1in]{geometry}

%%% User specified packages and stylesheets
\usepackage{alectryon}
\usepackage{pygments}

%%% Fallback definitions for Docutils-specific commands

% class handling for environments (block-level elements)
% \begin{DUclass}{spam} tries \DUCLASSspam and
% \end{DUclass}{spam} tries \endDUCLASSspam
\ifx\DUclass\undefined % poor man's "provideenvironment"
 \newenvironment{DUclass}[1]%
  {\def\DocutilsClassFunctionName{DUCLASS#1}% arg cannot be used in end-part of environment.
     \csname \DocutilsClassFunctionName \endcsname}%
  {\csname end\DocutilsClassFunctionName \endcsname}%
\fi

% admonition (specially marked topic)
\providecommand{\DUadmonition}[2][class-arg]{%
  % try \DUadmonition#1{#2}:
  \ifcsname DUadmonition#1\endcsname%
    \csname DUadmonition#1\endcsname{#2}%
  \else
    \begin{center}
      \fbox{\parbox{0.9\linewidth}{#2}}
    \end{center}
  \fi
}
% basic code highlight:
\providecommand*\DUrolecomment[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\providecommand*\DUroledeleted[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\providecommand*\DUrolekeyword[1]{\textbf{#1}}
\providecommand*\DUrolestring[1]{\textit{#1}}

% inline markup (custom roles)
% \DUrole{#1}{#2} tries \DUrole#1{#2}
\providecommand*{\DUrole}[2]{%
  \ifcsname DUrole#1\endcsname%
    \csname DUrole#1\endcsname{#2}%
  \else
    % backwards compatibility: try \docutilsrole#1{#2}
    \ifcsname docutilsrole#1\endcsname%
      \PackageWarningNoLine{docutils}{Command prefix "docutilsrole" is
         deprecated, \MessageBreak use `\protect\DUrole #1`}
      \csname docutilsrole#1\endcsname{#2}%
    \else%
      #2%
    \fi%
  \fi%
}

% title for topics, admonitions, unsupported section levels, and sidebar
\providecommand*{\DUtitle}[2][class-arg]{%
  % call \DUtitle#1{#2} if it exists:
  \ifcsname DUtitle#1\endcsname%
    \csname DUtitle#1\endcsname{#2}%
  \else
    \smallskip\noindent\textbf{#2}\smallskip%
  \fi
}

% hyperlinks:
\ifthenelse{\isundefined{\hypersetup}}{
  \usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue]{hyperref}
  \usepackage{bookmark}
  \urlstyle{same} % normal text font (alternatives: tt, rm, sf)
}{}
\hypersetup{
  pdftitle={Proof Engine},
}

%%% Body
\begin{document}
\title{Proof Engine%
  \label{proof-engine}}
\author{}
\date{}
\maketitle

To compile:

\begin{quote}
\begin{alltt}
alectryon literate_easycrypt.ec.rst
    # reST → HTML; produces ‘literate_easycrypt.html’
$ DOCUTILSCONFIG=literate.docutils.conf alectryon \textbackslash{}
  literate_easycrypt.ec.rst -{}-backend latex
    # reST → HTML; produces ‘literate_easycrypt.tex’
\end{alltt}
\end{quote}

EasyCrypt’s proof engine works with goal lists, where a \emph{goal} has
two parts:

\begin{itemize}
\item A \emph{context} consisting of a

\begin{itemize}
\item a set of type variables, and

\item an \emph{ordered} set of \emph{assumptions}, consisting of identifiers with
their types, memories, module names with their module types and
restrictions, local definitions, and \emph{hypotheses}, i.e., formulas.
An identifier’s type may involve the type variables, the local
definitions and formulas may involve the type variables,
identifiers, memories and module names.
\end{itemize}

\item A \emph{conclusion}, consisting of a single formula, with the same
constraints as the assumption formulas.
\end{itemize}

Informally, to prove a goal, one must show the conclusion to be true,
given the truth of the hypotheses, for all valid instantiations of the
assumption identifiers, memories and module names.

For example, the following is a goal:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{\char`\'a, \char`\'b}{\PY{n+nv+vm}{type}}
            \sep
            \hyp{x, x\char`\'}{\PY{n+nv+vm}{\PYZsq{}a}}
            \sep
            \hyp{y, y\char`\'}{\PY{n+nv+vm}{\PYZsq{}b}}
            \sep
            \hyp{eq\char`\_xx\char`\'}{\PY{n}{x}~=~\PY{n}{x\PYZsq{}}}
            \sep
            \hyp{eq\char`\_yy\char`\'}{\PY{n}{y}~=~\PY{n}{y\PYZsq{}}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            (\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
\end{alectryon}

And, in the context of the following declarations:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{module}~\PY{k+kn}{type}~\PY{n}{T}~=~\PYZob{}\nl
      ~~\PY{n+nb}{proc}~\PY{n}{f}()~:~\PY{n}{unit}\nl
      \PYZcb{}.\nl
    \end{input}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{module}~\PY{n}{G}(\PY{n}{X}~:~\PY{n}{T})~=~\PYZob{}\nl
      ~~\PY{k+kr}{var}~\PY{n}{x}~:~\PY{n}{int}\nl
      ~~\PY{n+nb}{proc}~\PY{n}{g}()~:~\PY{n}{unit}~=~\PYZob{}\nl
      ~~~~\PY{n}{X}.\PY{n}{f}();\nl
      ~~\PYZcb{}\nl
      \PYZcb{}.
    \end{input}
  \end{sentence}
\end{alectryon}

… the following is a goal:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{X}{\PY{n}{T}\PYZob{}\PY{n}{G}\PYZcb{}}
            \sep
            \hyp{n}{\PY{n}{int}}
            \sep
            \hyp{LL}{\PY{k+kr}{islossless}~\PY{n}{X}.\PY{n}{f}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{g+gs}{Context~:}~\PY{n}{G}(\PY{n}{X}).\PY{n}{g}\nl
            \PY{g+gs}{Bound~~~:}~[=]~\PY{n}{1}\PY{l+s+sa}{\PYZpc{}r}\nl
            \nl
            \PY{g+gs}{pre~=}~\PY{n}{G}.\PY{n}{x}~=~\PY{n}{n}\nl
            \nl
            \PY{n+nl}{(1)}~~\PY{n}{X}.\PY{n}{f}()\nl
            \nl
            \PY{g+gs}{post~=}~\PY{n}{G}.\PY{n}{x}~=~\PY{n}{n}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
\end{alectryon}

The conclusion of this goal is just a nonlinear rendering of the following
formula, as EasyCrypt’s pretty printer renders \emph{pRHL}, \emph{pHL} and \emph{HL}
judgements in such a nonlinear style when the judgements appear as (as opposed
to in) the conclusions of goals

\begin{DUclass}{code}
\begin{DUclass}{easycrypt}
\begin{quote}
\ttfamily\raggedright
\DUrole{kr}{phoare}~{[}\DUrole{n}{G}(\DUrole{n}{X}).\DUrole{n}{g}~:~\DUrole{n}{G}.\DUrole{n}{x}~=~\DUrole{n}{n}~==>~\DUrole{n}{G}.\DUrole{n}{x}~=~\DUrole{n}{n}{]}~=~\DUrole{n}{1}\DUrole{sa}{\%r}.
\end{quote}
\end{DUclass}
\end{DUclass}

Internally, EasyCrypt’s proof engine also works with \emph{pRHL},
\emph{pHL} and \emph{HL} judgments involving lists of statements rather than
procedure names, which we’ll call \emph{statement judgements}, below. For
example, take the following declaration:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{module}~\PY{n}{M}~=~\PYZob{}\nl
      ~~\PY{n+nb}{proc}~\PY{n}{f}(\PY{n}{y}~:~\PY{n}{int})~=~\PYZob{}\nl
      ~~~~\PY{k+kr}{if}~(\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{1})~\PY{n}{y}~\PYZlt{}\PYZhy{}~\PY{n}{y}~+~\PY{n}{4};\nl
      ~~~~\PY{k+kr}{else}~\PY{n}{y}~\PYZlt{}\PYZhy{}~\PY{n}{y}~+~\PY{n}{2};\nl
      ~~~~\PY{k+kr}{return}~\PY{n}{y};\nl
      ~~\PYZcb{}\nl
      \PYZcb{}.
    \end{input}
  \end{sentence}
\end{alectryon}

This is a \emph{pHL} statement judgement:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
            \sep
            \hyp{zor1\char`\_x}{\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{g+gs}{Context~:}~\PY{n}{M}.\PY{n}{f}\nl
            \nl
            \PY{g+gs}{pre~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~/\PYZbs{}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{1}\nl
            \nl
            \PY{n+nl}{(1)}~~\PY{n}{y}~\PYZlt{}\PYZhy{}~\PY{n}{y}~+~\PY{n}{4}\nl
            \nl
            \PY{g+gs}{post~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
\end{alectryon}

The pre- and post-conditions of a statement judgement may refer to the
parameters and local variables of the \emph{procedure context} of the
conclusion—\texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{n}{M}.\DUrole{n}{f}}}}} in the preceding example. They may also refer to
the memories \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\&\DUrole{n}{1}}}}} and \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\&\DUrole{n}{2}}}}} in the case of \emph{pRHL} statement
judgements. When a statement judgement appears anywhere other than as
the conclusion of a goal, the pretty printer renders it in abbreviated
linear syntax. E.g., the preceding goal is rendered as

\begin{DUclass}{code}
\begin{DUclass}{easycrypt}
\begin{quote}
\ttfamily\raggedright
\DUrole{kr}{hoare}{[}\DUrole{kr}{if}~(\DUrole{n}{x}~\%\%~\DUrole{n}{3}~=~\DUrole{n}{1})~\{...\}~:~\DUrole{n}{x}~\%\%~\DUrole{n}{3}~=~\DUrole{n}{n}~==>~\DUrole{n}{x}~\%\%~\DUrole{n}{3}~=~\DUrole{n}{n}~\%\%~\DUrole{n}{2}~+~\DUrole{n}{1}{]}
\end{quote}
\end{DUclass}
\end{DUclass}

Statement judgements can’t be directly input by the user.

We use the term \emph{program} to refer to \emph{either} a procedure appearing in
a \emph{pRHL}, \emph{pHL} or \emph{HL} judgement, \emph{or} a statement list
appearing in a \emph{pRHL}, \emph{pHL} or \emph{HL} statement judgement. In
the case of \emph{pRHL} (statement) judgements, we speak of the \emph{left} and
\emph{right} programs, also using \emph{program 1} for the left program, and
\emph{program 2} for the right one. We will only speak of a program’s
\emph{length} when it’s a statement list we are referring to. By the \emph{empty}
program, we mean the statement list with no statements.

When the proof of a lemma is begun, the proof engine starts out with a
single goal, consisting of the lemma’s statement:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{lemma}~\PY{n}{PairEq}~[\PY{n+nv+vm}{\PYZsq{}a},~\PY{n+nv+vm}{\PYZsq{}b}]~:\nl
      ~~\PY{k+kr}{forall}~(\PY{n}{x}~\PY{n}{x\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}a})~(\PY{n}{y}~\PY{n}{y\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}b}),\nl
      ~~\PY{n}{x}~=~\PY{n}{x\PYZsq{}}~=\PYZgt{}~\PY{n}{y}~=~\PY{n}{y\PYZsq{}}~=\PYZgt{}~(\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}}).
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{\char`\'a, \char`\'b}{\PY{n+nv+vm}{type}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{k+kr}{forall}~(\PY{n}{x}~\PY{n}{x\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}a})~(\PY{n}{y}~\PY{n}{y\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}b}),\nl
            ~~\PY{n}{x}~=~\PY{n}{x\PYZsq{}}~=\PYZgt{}~\PY{n}{y}~=~\PY{n}{y\PYZsq{}}~=\PYZgt{}~(\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
\end{alectryon}

For parameterized lemmas, the goal includes the lemma’s parameters as
assumptions. E.g.,

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{lemma}~\PY{n}{PairEq\PYZus{}param}~(\PY{n}{x}~\PY{n}{x\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}a})~(\PY{n}{y}~\PY{n}{y\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}b})~:\nl
      ~~\PY{n}{x}~=~\PY{n}{x\PYZsq{}}~=\PYZgt{}~\PY{n}{y}~=~\PY{n}{y\PYZsq{}}~=\PYZgt{}~(\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}}).
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{\char`\'a, \char`\'b}{\PY{n+nv+vm}{type}}
            \sep
            \hyp{x, x\char`\'}{\PY{n+nv+vm}{\PYZsq{}a}}
            \sep
            \hyp{y, y\char`\'}{\PY{n+nv+vm}{\PYZsq{}b}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{n}{x}~=~\PY{n}{x\PYZsq{}}~=\PYZgt{}~\PY{n}{y}~=~\PY{n}{y\PYZsq{}}~=\PYZgt{}~(\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
\end{alectryon}

EasyCrypt’s tactics, when applicable, reduce the first goal to zero or
more subgoals.  Here is a detailed example.  We start with a lemma
statement:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{lemma}~\PY{n}{L}~(\PY{n}{x}~:~\PY{n}{int})~:\nl
      ~~\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}~=\PYZgt{}\nl
      ~~\PY{k+kr}{hoare}[\PY{n}{M}.\PY{n}{f}~:~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~==\PYZgt{}~\PY{k+kr}{res}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~(\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2})~+~\PY{n}{1}].
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}~=\PYZgt{}\nl
            \PY{k+kr}{hoare}[~\PY{n}{M}.\PY{n}{f}~:~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~==\PYZgt{}~\PY{k+kr}{res}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}]
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
\end{alectryon}

Then, we proceed through the proof step by step:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \anchor{literate-easycrypt-ec-rst-s-proof-0}\PY{k+kn}{proof}.\mrefmarker{1}
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}~=\PYZgt{}\nl
            \PY{k+kr}{hoare}[~\PY{n}{M}.\PY{n}{f}~:~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~==\PYZgt{}~\PY{k+kr}{res}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}]
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      \anchor{literate-easycrypt-ec-rst-s-move-0}~~\PY{n+nb}{move}=\PYZgt{}~\PY{n}{zor1\PYZus{}x}.\mrefmarker{2}
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
            \sep
            \hyp{zor1\char`\_x}{\anchor{literate-easycrypt-ec-rst-s-move-h-x-1-0}\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}\mrefmarker{3}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{g+gs}{pre~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}\nl
            \nl
            ~~~~\PY{n}{M}.\PY{n}{f}\nl
            \nl
            \PY{g+gs}{post~=}~\PY{k+kr}{res}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      \anchor{literate-easycrypt-ec-rst-s-proc-0}~~\PY{n+nb}{proc}.\mrefmarker{4}
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
            \sep
            \hyp{zor1\char`\_x}{\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{g+gs}{Context~:}~\PY{n}{M}.\PY{n}{f}\nl
            \nl
            \PY{g+gs}{pre~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}\nl
            \nl
            \PY{n+nl}{(1\PYZhy{}\PYZhy{})}~~\PY{k+kr}{if}~(\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{1})~\PYZob{}\nl
            \PY{n+nl}{(1.1)}~~~~\PY{n}{y}~\PYZlt{}\PYZhy{}~\PY{n}{y}~+~\PY{n}{4}\nl
            \PY{n+nl}{(1\PYZhy{}\PYZhy{})}~~\PYZcb{}~\PY{k+kr}{else}~\PYZob{}\nl
            \PY{n+nl}{(1?1)}~~~~\PY{n}{y}~\PYZlt{}\PYZhy{}~\PY{n}{y}~+~\PY{n}{2}\nl
            \PY{n+nl}{(1\PYZhy{}\PYZhy{})}~~\PYZcb{}\nl
            \nl
            \PY{g+gs}{post~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
\end{alectryon}

The \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{kn}{proof}}}}} command \hyperref[literate-easycrypt-ec-rst-s-proof-0]{1} starts the tactic script.  The \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{nb}{move}}}}} \hyperref[literate-easycrypt-ec-rst-s-move-0]{2} then introduces the left part of the implication into the context, creating hypothesis \alectryonInline{\hyp{zor1\char`\_x}{\PY{n}{x}~\PY{o}{=}~\PY{l+m+mi}{1}~\PY{o}{\PYZbs{}/}~\PY{n}{x}~\PY{o}{=}~\PY{l+m+mi}{2}}} (\hyperref[literate-easycrypt-ec-rst-s-move-h-x-1-0]{3}).  The following tactic, \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{nb}{proc}}}}} \hyperref[literate-easycrypt-ec-rst-s-proc-0]{4}, unfold \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{n}{M}.\DUrole{n}{f}}}}} and displays its code.  Given that the code includes a branch, we then invoke the \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{kr}{if}}}}} tactic, which creates two goals: one for the \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{kr}{if}}}}} branch and one for the \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{kr}{else}}}}} branch:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
            \sep
            \hyp{zor1\char`\_x}{\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{g+gs}{Context~:}~\PY{n}{M}.\PY{n}{f}\nl
            \nl
            \PY{g+gs}{pre~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~/\PYZbs{}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{1}\nl
            \nl
            \PY{n+nl}{(1)}~~\PY{n}{y}~\PYZlt{}\PYZhy{}~\PY{n}{y}~+~\PY{n}{4}\nl
            \nl
            \PY{g+gs}{post~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
\end{alectryon}

We handle both goals in the same way; first, the \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{kr}{if}}}}} branch:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \anchor{literate-easycrypt-ec-rst-s-wp-0}~~~~\PY{n+nb}{wp}.\mrefmarker{5}
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
            \sep
            \hyp{zor1\char`\_x}{\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{g+gs}{Context~:}~\PY{n}{M}.\PY{n}{f}\nl
            \nl
            \PY{g+gs}{pre~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~/\PYZbs{}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{1}\nl
            \nl
            \nl
            \PY{g+gs}{post~=}~(\PY{n}{y}~+~\PY{n}{4})~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      \anchor{literate-easycrypt-ec-rst-s-skip-0}~~~~\PY{n+nb}{skip}.\mrefmarker{6}
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
            \sep
            \hyp{zor1\char`\_x}{\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{k+kr}{forall}~\PYZam{}\PY{n}{hr},\nl
            ~~\PY{n}{y}\PYZob{}\PY{n}{hr}\PYZcb{}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~/\PYZbs{}~\PY{n}{y}\PYZob{}\PY{n}{hr}\PYZcb{}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{1}~=\PYZgt{}\nl
            ~~(\PY{n}{y}\PYZob{}\PY{n}{hr}\PYZcb{}~+~\PY{n}{4})~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      \anchor{literate-easycrypt-ec-rst-s-smt-0}~~~~\PY{n+nb+bp}{smt}.\mrefmarker{7}
    \end{input}
  \end{sentence}
\end{alectryon}

The \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{nb}{wp}}}}} tactic \hyperref[literate-easycrypt-ec-rst-s-wp-0]{5} runs a weakest-precondition calculation, consuming the program and yielding a new postcondition; then \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{nb}{skip}}}}} \hyperref[literate-easycrypt-ec-rst-s-skip-0]{6} transforms the statement judgment about an empty program into a logic formula, and finally the \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{bp}{smt}}}}} tactic \hyperref[literate-easycrypt-ec-rst-s-smt-0]{7} solves the goal using
SMT provers, leaving no subgoals for this branch.

We solve the \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{kr}{else}}}}} branch in the same way;

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      ~~~~\PY{n+nb}{wp}.
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
            \sep
            \hyp{zor1\char`\_x}{\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{g+gs}{Context~:}~\PY{n}{M}.\PY{n}{f}\nl
            \nl
            \PY{g+gs}{pre~=}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~/\PYZbs{}~\PY{n}{y}~\PYZpc{}\PYZpc{}~\PY{n}{3}~\PYZlt{}\PYZgt{}~\PY{n}{1}\nl
            \nl
            \nl
            \PY{g+gs}{post~=}~(\PY{n}{y}~+~\PY{n}{2})~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      ~~~~\PY{n+nb}{skip}.
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{x}{\PY{n}{int}}
            \sep
            \hyp{zor1\char`\_x}{\PY{n}{x}~=~\PY{n}{1}~\PYZbs{}/~\PY{n}{x}~=~\PY{n}{2}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{k+kr}{forall}~\PYZam{}\PY{n}{hr},\nl
            ~~\PY{n}{y}\PYZob{}\PY{n}{hr}\PYZcb{}~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~/\PYZbs{}~\PY{n}{y}\PYZob{}\PY{n}{hr}\PYZcb{}~\PYZpc{}\PYZpc{}~\PY{n}{3}~\PYZlt{}\PYZgt{}~\PY{n}{1}~=\PYZgt{}\nl
            ~~(\PY{n}{y}\PYZob{}\PY{n}{hr}\PYZcb{}~+~\PY{n}{2})~\PYZpc{}\PYZpc{}~\PY{n}{3}~=~\PY{n}{x}~\PYZpc{}\PYZpc{}~\PY{n}{2}~+~\PY{n}{1}
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      ~~~~\PY{n+nb+bp}{smt}.
    \end{input}
    \sep
    \begin{output}
      \begin{messages}
        \begin{message}
          \PY{n}{No}~\PY{n}{more}~\PY{n}{goals}
        \end{message}
      \end{messages}
    \end{output}
  \end{sentence}
\end{alectryon}

A finally, the lemma’s proof may be saved, using the step \texttt{\DUrole{code}{\DUrole{highlight}{\DUrole{easycrypt}{\DUrole{kn}{qed}}}}}, when
the list of goals becomes empty. And this must be done before anything
else may be done.

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{qed}.
    \end{input}
    \sep
    \begin{output}
      \begin{messages}
        \begin{message}
          +~\PY{n}{added}~\PY{k+kn}{lemma}:~`\PY{n}{L\PYZsq{}}
        \end{message}
      \end{messages}
    \end{output}
  \end{sentence}
\end{alectryon}

Here is how the proof of the pair-equality lemma goes:

\begin{alectryon}
  % Generator: Alectryon
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{lemma}~\PY{n}{PairEq}~[\PY{n+nv+vm}{\PYZsq{}a},~\PY{n+nv+vm}{\PYZsq{}b}]~:\nl
      ~~\PY{k+kr}{forall}~(\PY{n}{x}~\PY{n}{x\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}a})~(\PY{n}{y}~\PY{n}{y\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}b}),\nl
      ~~\PY{n}{x}~=~\PY{n}{x\PYZsq{}}~=\PYZgt{}~\PY{n}{y}~=~\PY{n}{y\PYZsq{}}~=\PYZgt{}~(\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}}).
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{\char`\'a, \char`\'b}{\PY{n+nv+vm}{type}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{k+kr}{forall}~(\PY{n}{x}~\PY{n}{x\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}a})~(\PY{n}{y}~\PY{n}{y\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}b}),\nl
            ~~\PY{n}{x}~=~\PY{n}{x\PYZsq{}}~=\PYZgt{}~\PY{n}{y}~=~\PY{n}{y\PYZsq{}}~=\PYZgt{}~(\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{proof}.
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{\char`\'a, \char`\'b}{\PY{n+nv+vm}{type}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{k+kr}{forall}~(\PY{n}{x}~\PY{n}{x\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}a})~(\PY{n}{y}~\PY{n}{y\PYZsq{}}~:~\PY{n+nv+vm}{\PYZsq{}b}),\nl
            ~~\PY{n}{x}~=~\PY{n}{x\PYZsq{}}~=\PYZgt{}~\PY{n}{y}~=~\PY{n}{y\PYZsq{}}~=\PYZgt{}~(\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      ~~\PY{n+nb}{move}=\PYZgt{}~\PY{n}{x}~\PY{n}{x\PYZsq{}}~\PY{n}{y}~\PY{n}{y\PYZsq{}}.
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{\char`\'a, \char`\'b}{\PY{n+nv+vm}{type}}
            \sep
            \hyp{x, x\char`\'}{\PY{n+nv+vm}{\PYZsq{}a}}
            \sep
            \hyp{y, y\char`\'}{\PY{n+nv+vm}{\PYZsq{}b}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            \PY{n}{x}~=~\PY{n}{x\PYZsq{}}~=\PYZgt{}~\PY{n}{y}~=~\PY{n}{y\PYZsq{}}~=\PYZgt{}~(\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      ~~\PY{n+nb}{move}=\PYZgt{}~\PY{n}{eq\PYZus{}xx\PYZsq{}}~\PY{n}{eq\PYZus{}yy\PYZsq{}}.
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{\char`\'a, \char`\'b}{\PY{n+nv+vm}{type}}
            \sep
            \hyp{x, x\char`\'}{\PY{n+nv+vm}{\PYZsq{}a}}
            \sep
            \hyp{y, y\char`\'}{\PY{n+nv+vm}{\PYZsq{}b}}
            \sep
            \hyp{eq\char`\_xx\char`\'}{\PY{n}{x}~=~\PY{n}{x\PYZsq{}}}
            \sep
            \hyp{eq\char`\_yy\char`\'}{\PY{n}{y}~=~\PY{n}{y\PYZsq{}}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            (\PY{n}{x},~\PY{n}{y})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      ~~\PY{n+nb}{rewrite}~\PY{n}{eq\PYZus{}xx\PYZsq{}}~\PY{n}{eq\PYZus{}yy\PYZsq{}}.
    \end{input}
    \sep
    \begin{output}
      \begin{goals}
        \begin{goal}
          \begin{hyps}
            \hyp{\char`\'a, \char`\'b}{\PY{n+nv+vm}{type}}
            \sep
            \hyp{x, x\char`\'}{\PY{n+nv+vm}{\PYZsq{}a}}
            \sep
            \hyp{y, y\char`\'}{\PY{n+nv+vm}{\PYZsq{}b}}
            \sep
            \hyp{eq\char`\_xx\char`\'}{\PY{n}{x}~=~\PY{n}{x\PYZsq{}}}
            \sep
            \hyp{eq\char`\_yy\char`\'}{\PY{n}{y}~=~\PY{n}{y\PYZsq{}}}
          \end{hyps}
          \sep
          \infrule{}
          \sep
          \begin{conclusion}
            (\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})~=~(\PY{n}{x\PYZsq{}},~\PY{n}{y\PYZsq{}})
          \end{conclusion}
        \end{goal}
      \end{goals}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      ~~\PY{n+nb+bp}{reflexivity}.
    \end{input}
    \sep
    \begin{output}
      \begin{messages}
        \begin{message}
          \PY{n}{No}~\PY{n}{more}~\PY{n}{goals}
        \end{message}
      \end{messages}
    \end{output}
  \end{sentence}
  \sep
  \begin{sentence}
    \begin{input}
      \PY{k+kn}{qed}.
    \end{input}
    \sep
    \begin{output}
      \begin{messages}
        \begin{message}
          +~\PY{n}{added}~\PY{k+kn}{lemma}:~`\PY{n}{PairEq\PYZsq{}}
        \end{message}
      \end{messages}
    \end{output}
  \end{sentence}
\end{alectryon}

\DUadmonition[note]{
\DUtitle[note]{Note}

Applying a tactic may fail; in this case an error message is issued and
the list of goals is left unchanged.

% FIXME: needs a way to allow errors in compilation mode too.
% 
% For example:
% 
% .. easycrypt::
% 
%    lemma eq_refl ['a] (x: 'a) : x = x.
%    proof.
%      move=> y. (* .unfold *)
%    abort.
}

\end{document}
